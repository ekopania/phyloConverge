require('rphast')

#'Computes bias-corrected conservation/acceleration score of a given feature using maximum likelihood estimation of branch scaling and phylogenetic permulations (phylogeny-aware permutation test)
#' @param foregrounds a character vector containing the names of the foreground species
#' @param permulated_foregrounds a list object containing the sets of fake foreground species generated by permulation
#' @param neutralMod neutral nucleutide substitution model
#' @param maf an MSA object containing the sequence alignment
#' @param refseq reference species
#' @param feature a feature object containing information on chromosomes, coordinates, and names (optional) of the features to be scored
#' @param alpha target significance level to control for
#' @param min.fg minimum number of foreground species required
#' @param method scoring method for phyloP (default "LRT")
#' @param mode scoring mode for phyloP (default "CONACC")
#' @param adapt Boolean flag for performing adaptive permulation (adapt = TRUE for adaptive permulation, adapt = FALSE for complete permulations, default TRUE)
#' @param phyloP_outfile a string for naming the phyloP output file for the real data; default is NULL which will return no phyloP output file
#' @return out a data frame containing phyloConverge permulation p-values, corrected score, and uncorrected score (negative score denotes acceleration, positive score denotes deceleration)
#' @export
phyloConverge=function(foregrounds, permulated_foregrounds, neutralMod, maf, refseq, feature=NULL, alpha=0.05, min.fg=2, method="LRT", mode="CONACC", adapt=T, phyloP_outfile=NULL){
  fg_exist = checkForegrounds(maf, foregrounds)
  #Counts the number of foreground TIPS present in the alignment
  #fg_exist also looks for internal nodes, so we need a separate function instead of length(fg_exist)
  num_fg = countFgTips(maf, foregounds)
  if (is.null(feature)){
    feature = convertAlignmentToFeature(maf, refseq)
  }
  if (length(unique(feature$feature) == 1)){
    if (unique(feature$feature)=='.'){
      feature_names = paste0("feature", seq(1, nrow(feature),1))
    }
  }
  if (length(fg_exist) >= min.fg){
    out = NULL
    for (i in 1:nrow(feature)){
      print(paste("Scoring feature", i, "/", nrow(feature), feature_names[i]))
      #out_i = run_phyloConverge(fg_exist, permulated_foregrounds, neutralMod, maf, refseq, feature=feature[i,], alpha=alpha, min.fg=min.fg, method=method, mode=mode, adapt=adapt)
      #Run new version that takes continuous permulated traits as input
      out_i = run_phyloConverge_continuousTraitPermulations(fg_exist, num_fg, permulated_foregrounds, neutralMod, maf, refseq, feature=feature[i,], alpha=alpha, min.fg=min.fg, method=method, mode=mode, adapt=adapt, phyloP_outfile=phyloP_outfile)
      out = rbind(out, out_i)
    }
  } else {
    permPval = rep(NA,nrow(feature))
    observed.score = rep(NA,nrow(feature))
    corr_score = rep(NA,nrow(feature))
    out = data.frame("permPval"=permPval, "corr_score"=corr_score, "uncorr_score"=observed.score)
  }
  out$feature = feature_names
  out
}

#' @keywords internal
run_phyloConverge=function(foregrounds, permulated_foregrounds, neutralMod, maf, refseq, feature=NULL, alpha=0.05, min.fg=2, method="LRT", mode="CONACC", adapt=T, phyloP_outfile=NULL){
  #Save full phyloP result for the real data to outfile; by default name is phyloP_result.<maf_filename>.txt
  observed.score = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=foregrounds, outfile=phyloP_outfile)
  observed.score = observed.score$score
  if (adapt){
    max_permulations = length(permulated_foregrounds)
    maxnum_extreme = round(alpha*max_permulations) ### centering on median --> the same pruning threshold on both sides
    permulated_scores = rep(NA, length(permulated_foregrounds))
    for (i in 1:length(permulated_foregrounds)){
      fg_exist = checkForegrounds(maf, permulated_foregrounds[[i]])
      if (length(fg_exist) >= min.fg){
        permulated_score_i = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=fg_exist)
        permulated_scores[i] = permulated_score_i$score
        computed_permulated_scores = permulated_scores[!is.na(permulated_scores)]
        if (length(computed_permulated_scores) >= 2*maxnum_extreme){
          median_null_scores = median(computed_permulated_scores)
          if (observed.score <= median_null_scores){
            one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores < median_null_scores)]
            ind_nonextreme = which(one_sided_null_scores > observed.score)
            ind_extreme = which(one_sided_null_scores <= observed.score)
          } else if (observed.score > median_null_scores){
            one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores > median_null_scores)]
            ind_nonextreme = which(one_sided_null_scores < observed.score)
            ind_extreme = which(one_sided_null_scores >= observed.score)
          }

          if (length(ind_extreme) > maxnum_extreme || i == length(permulated_foregrounds)){
            permPval = min(maxnum_extreme+1, length(ind_extreme)+1)/(length(one_sided_null_scores)+1)   ###min(length(computed_permulated_scores)+1, length(permulated_foregrounds)+1)
            corr_score = sign(observed.score-median_null_scores)*(-log10(permPval))
            break
          }
        }
      }
    }
  } else {
    permulated_scores = rep(NA, length(permulated_foregrounds))
    for (i in 1:length(permulated_foregrounds)){
      fg_exist = checkForegrounds(maf, permulated_foregrounds[[i]])
      if (length(fg_exist) >= min.fg){
        permulated_score_i = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=fg_exist)
        permulated_scores[i] = permulated_score_i$score
      }
    }
    computed_permulated_scores = permulated_scores[!is.na(permulated_scores)]
    median_null_scores = median(computed_permulated_scores)
    if (observed.score <= median_null_scores){
      one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores < median_null_scores)]
      ind_extreme = which(one_sided_null_scores <= observed.score)
    } else if (observed.score > median_null_scores){
      one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores > median_null_scores)]
      ind_extreme = which(one_sided_null_scores >= observed.score)
    }

    permPval = (length(ind_extreme)+1)/(length(one_sided_null_scores)+1)
    corr_score = sign(observed.score - median_null_scores)*(-log10(permPval))
  }
  out = data.frame("permPval"=permPval, "corr_score"=corr_score, "uncorr_score"=observed.score)
  out
}

#' @keywords internal
#' Runs phyloConverge for one feature using permulated continuous traits
#' @param foregrounds a character vector containing the names of the real foreground species and internal nodes
#' @param num_foreground_tips number of foreground tips in the real data present in this alignment
#' @param permulated_foregrounds a list object containing the named vectors of simulated continuous foreground traits generated by permulation
#' @param neutralMod neutral nucleutide substitution model
#' @param maf an MSA object containing the sequence alignment
#' @param refseq reference species
#' @param feature a feature object containing information on chromosomes, coordinates, and names (optional) of the features to be scored
#' @param alpha target significance level to control for
#' @param min.fg minimum number of foreground species required
#' @param method scoring method for phyloP (default "LRT")
#' @param mode scoring mode for phyloP (default "CONACC")
#' @param adapt Boolean flag for performing adaptive permulation (adapt = TRUE for adaptive permulation, adapt = FALSE for complete permulations, default TRUE)
#' @param phyloP_outfile a string for naming the phyloP output file for the real data; default is NULL which will return no phyloP output file
run_phyloConverge_continuousTraitPermulations=function(foregrounds, num_foreground_tips, permulated_foregrounds, neutralMod, maf, refseq, feature=NULL, alpha=0.05, min.fg=2, method="LRT", mode="CONACC", adapt=T, phyloP_outfile=NULL){
  print("Running phyloConverge with continuous trait permulations as input")
  #PHYLOP AUTOMATICALLY PRUNES TREE TO ONLY INCLUDE SPECIES IN ALIGNMENT - GIVES WARNING MESSAGE
  #Added optional parameter to save full phyloP result for the real data to output file
  observed.score = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=foregrounds, outfile=phyloP_outfile)
  observed.score = observed.score$score

  #Get neutral tree from neutral tree model
  neutral_tree<-read.tree(text=myMod$tree)
  print(neutral_tree)

  #Makes neutral tree into a list of trees of length 1; necessary for some functions to read it properly
  masterTree = list()
  masterTree[[1]] = neutral_tree
  names(masterTree) = c("masterTree")
  if (adapt){
    max_permulations = length(permulated_foregrounds)
    maxnum_extreme = round(alpha*max_permulations) ### centering on median --> the same pruning threshold on both sides
    permulated_scores = rep(NA, length(permulated_foregrounds))
    for (i in 1:length(permulated_foregrounds)){
      #Subset permulated continuous data to only include species in alignment
      subset_perm = permulated_foregrounds[[i]][which(names(permulated_foregrounds[[i]]) %in% names(maf))]
      #print("Subset of permulated continuous trait values:")
      #print(length(subset_perm))
      #print(subset_perm)
      
      #Get top n permulated foregrounds, where n is the number of real foreground tips present in this aln
      sort_perm = (-(sort(subset_perm)))
      #print("Sorted permulated continuous traits:")
      #print(sort_perm)
      perm_fg_species = names(sort_perm)[1:num_foreground_tips]
      #print("Permulated foreground tips:")
      #print(length(perm_fg_species))
      #print(perm_fg_species)

      #Use RERconverge function foreground2Tree with clade=all to generate a tree in which the foreground tips and internal fg nodes have a branch length of 1; all internal nodes for which all descendents are fg will also be considered fg
      fg2t_all = foreground2Tree(perm_fg_species, masterTree, plotTree=F, clade="all", useSpecies=names(maf))
      #Name the foreground tree edge lengths based on tip and internal node names for the given tree
      names(fg2t_all$edge.length)=nameEdges_all(fg2t_all)
      #print(fg2t_all$edge.length)
      #Permulated foregrounds will be all tips and internal nodes with an edge length of 1
      fg_exist = names(fg2t_all$edge.length)[which(fg2t_all$edge.length==1)]
      #print(fg_exist)
      #The rest of the function should work as before
      if (length(fg_exist) >= min.fg){
        permulated_score_i = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=fg_exist)
        permulated_scores[i] = permulated_score_i$score
        computed_permulated_scores = permulated_scores[!is.na(permulated_scores)]
        if (length(computed_permulated_scores) >= 2*maxnum_extreme){
          median_null_scores = median(computed_permulated_scores)
          if (observed.score <= median_null_scores){
            one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores < median_null_scores)]
            ind_nonextreme = which(one_sided_null_scores > observed.score)
            ind_extreme = which(one_sided_null_scores <= observed.score)
          } else if (observed.score > median_null_scores){
            one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores > median_null_scores)]
            ind_nonextreme = which(one_sided_null_scores < observed.score)
            ind_extreme = which(one_sided_null_scores >= observed.score)
          }

          if (length(ind_extreme) > maxnum_extreme || i == length(permulated_foregrounds)){
            permPval = min(maxnum_extreme+1, length(ind_extreme)+1)/(length(one_sided_null_scores)+1)   ###min(length(computed_permulated_scores)+1, length(permulated_foregrounds)+1)
            corr_score = sign(observed.score-median_null_scores)*(-log10(permPval))
            break
          }
        }
      }
    }
  } else {
    permulated_scores = rep(NA, length(permulated_foregrounds))
    for (i in 1:length(permulated_foregrounds)){
      #Subset permulated foregrounds to only include species in alignment
      subset_perm_fg = permulated_foregrounds[[i]][which(names(permulated_foregrounds[[i]]) %in% names(maf))]
      #Get top n permulated foregrounds, where n is the number of real foreground tips present in this aln
      sort_perm_fg = (-(sort(subset_perm_fg)))
      perm_fg_species = names(sort_perm_fg)[1:num_foreground_tips]
      #Get internal nodes from sister permulated foreground species
      fg2t_all = foreground2Tree(perm_fg_species, masterTree, plotTree=F, clade="all", useSpecies=names(maf))
      names(fg2t_all$edge.length)=nameEdges_all(fg2t_all)
      #Permulated foregrounds are a combination of foreground species and foreground internal branches
      fg_exist = names(fg2t_all$edge.length)[which(fg2t_all$edge.length==1)]
      #The rest of the function should work as before
      if (length(fg_exist) >= min.fg){
        permulated_score_i = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=fg_exist)
        permulated_scores[i] = permulated_score_i$score
      }
    }
    computed_permulated_scores = permulated_scores[!is.na(permulated_scores)]
    median_null_scores = median(computed_permulated_scores)
    if (observed.score <= median_null_scores){
      one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores < median_null_scores)]
      ind_extreme = which(one_sided_null_scores <= observed.score)
    } else if (observed.score > median_null_scores){
      one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores > median_null_scores)]
      ind_extreme = which(one_sided_null_scores >= observed.score)
    }

    permPval = (length(ind_extreme)+1)/(length(one_sided_null_scores)+1)
    corr_score = sign(observed.score - median_null_scores)*(-log10(permPval))
  }
  out = data.frame("permPval"=permPval, "corr_score"=corr_score, "uncorr_score"=observed.score)
  out
}




#'Scan a given sequence alignment to compute bias-corrected conservation/acceleration scores
#' @param maf an MSA object containing the sequence alignment
#' @param foregrounds a character vector containing the names of the foreground species
#' @param permulated_foregrounds a list object containing the sets of fake foreground species generated by permulation
#' @param neutralMod neutral nucleutide substitution model
#' @param refseq reference species
#' @param offset offset for the coordinates in the alignment. If NULL, the offset specified in the alignment is used
#' @param stride interval (in bp) of positions of sliding windows to be scored (default 1, meaning scoring every nucleotide)
#' @param window size (in bp) of the sliding windows to be scored (default 1)
#' @param alpha target significance level to control for
#' @param min.fg minimum number of foreground species required
#' @param method scoring method for phyloP (default "LRT")
#' @param mode scoring mode for phyloP (default "CONACC")
#' @param adapt Boolean flag for performing adaptive permulation (adapt = TRUE for adaptive permulation, adapt = FALSE for complete permulations, default TRUE)
#' @return out_df a data frame containing the start and end coordinates of the sliding windows and their corresponding phyloConverge scores
#' @export
scanWithPhyloConverge=function(maf, foregrounds, permulated_foregrounds, neutralMod, refseq, offset=NULL, stride=1, window=1, alpha=0.05, min.fg=2, method="LRT", mode="CONACC", adapt=T){
  if (is.null(offset)){
    offset=maf$offset
    coord_range = coord.range.msa(maf) - offset
  } else {
    offset=offset
    coord_range = coord.range.msa(maf)
  }

  flank = (window-1)/2
  start_pos = (window-1)/2 + 1
  scored_pos = seq(start_pos, coord_range[2], stride)

  bed_table = data.frame("chr"=rep("chr1", length(scored_pos)), "start"=scored_pos-flank, "end"=scored_pos+flank, "pos"=as.character(scored_pos))
  featureout = convertBedToFeature(bed_table, refseq)

  scan_score = rep(NA, nrow(featureout))
  for (i in 1:nrow(featureout)){
    print(i)
    score_i = phyloConverge(foregrounds, permulated_foregrounds, neutralMod, maf, refseq, featureout[i,], alpha=alpha, min.fg=min.fg, method=method, mode=mode, adapt=adapt)
    scan_score[i] = score_i$corr_score
  }
  position = offset + scored_pos

  out_df = data.frame("start"=position-flank, "end"=position+flank, "corr_score"=scan_score)
  out_df
}

#'Count number of foreground tips present in alignment
#' @param maf an MSA object containing the sequence alignment
#' @param foregrounds a character vector containing the names of the foreground species
#' @export
countFgTips=function(maf, foregounds){
   tips<-names(maf)
   fg_count<-length(intersect(tips, foregrounds))
   fg_count
}

#' Get names for both tips and internal branches of a phylo object
#' @param tree a phylo object
#' @return a vector tip labels and node names, sorted to match tree$edge
#' @export
nameEdges_all=function(tree){
  all_labels = c(tree$tip.label, tree$node.label)
  labels_ordered = c()
  for(i in 1:nrow(tree$edge)){
    idx=tree$edge[i,2]
    labels_ordered = c(labels_ordered, all_labels[idx])
  }
  labels_ordered
}

