require('rphast')

#'Computes bias-corrected conservation/acceleration score of a given feature using maximum likelihood estimation of branch scaling and phylogenetic permulations (phylogeny-aware permutation test)
#' @param foregrounds a character vector containing the names of the foreground species
#' @param permulated_foregrounds a list object containing the sets of fake foreground species generated by permulation
#' @param neutralMod neutral nucleutide substitution model
#' @param maf an MSA object containing the sequence alignment
#' @param refseq reference species
#' @param feature a feature object containing information on chromosomes, coordinates, and names (optional) of the features to be scored
#' @param alpha target significance level to control for
#' @param min.fg minimum number of foreground species required
#' @param method scoring method for phyloP (default "LRT")
#' @param mode scoring mode for phyloP (default "CONACC")
#' @param adapt Boolean flag for performing adaptive permulation (adapt = TRUE for adaptive permulation, adapt = FALSE for complete permulations, default TRUE)
#' @return out a data frame containing phyloConverge permulation p-values, corrected score, and uncorrected score (negative score denotes acceleration, positive score denotes deceleration)
#' @export
phyloConverge=function(foregrounds, permulated_foregrounds, neutralMod, maf, refseq, feature=NULL, alpha=0.05, min.fg=2, method="LRT", mode="CONACC", adapt=T){
  fg_exist = checkForegrounds(maf, foregrounds)
  #Counts the number of foreground TIPS present in the alignment
  #fg_exist also looks for internal nodes, so we need a separate function instead of length(fg_exist)
  num_fg = countFgTips(maf, foregounds)
  if (is.null(feature)){
    feature = convertAlignmentToFeature(maf, refseq)
  }
  if (length(unique(feature$feature) == 1)){
    if (unique(feature$feature)=='.'){
      feature_names = paste0("feature", seq(1, nrow(feature),1))
    }
  }
  if (length(fg_exist) >= min.fg){
    out = NULL
    for (i in 1:nrow(feature)){
      print(paste("Scoring feature", i, "/", nrow(feature), feature_names[i]))
      #out_i = run_phyloConverge(fg_exist, permulated_foregrounds, neutralMod, maf, refseq, feature=feature[i,], alpha=alpha, min.fg=min.fg, method=method, mode=mode, adapt=adapt)
      #Run new version that takes continuous permulated traits as input
      out_i = run_phyloConverge_continuousTraitPermulations(fg_exist, num_fg, permulated_foregrounds, neutralMod, maf, refseq, feature=feature[i,], alpha=alpha, min.fg=min.fg, method=method, mode=mode, adapt=adapt)
      out = rbind(out, out_i)
    }
  } else {
    permPval = rep(NA,nrow(feature))
    observed.score = rep(NA,nrow(feature))
    corr_score = rep(NA,nrow(feature))
    out = data.frame("permPval"=permPval, "corr_score"=corr_score, "uncorr_score"=observed.score)
  }
  out$feature = feature_names
  out
}

#' @keywords internal
run_phyloConverge=function(foregrounds, permulated_foregrounds, neutralMod, maf, refseq, feature=NULL, alpha=0.05, min.fg=2, method="LRT", mode="CONACC", adapt=T){
  observed.score = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=foregrounds)
  observed.score = observed.score$score
  if (adapt){
    max_permulations = length(permulated_foregrounds)
    maxnum_extreme = round(alpha*max_permulations) ### centering on median --> the same pruning threshold on both sides
    permulated_scores = rep(NA, length(permulated_foregrounds))
    for (i in 1:length(permulated_foregrounds)){
      fg_exist = checkForegrounds(maf, permulated_foregrounds[[i]])
      if (length(fg_exist) >= min.fg){
        permulated_score_i = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=fg_exist)
        permulated_scores[i] = permulated_score_i$score
        computed_permulated_scores = permulated_scores[!is.na(permulated_scores)]
        if (length(computed_permulated_scores) >= 2*maxnum_extreme){
          median_null_scores = median(computed_permulated_scores)
          if (observed.score <= median_null_scores){
            one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores < median_null_scores)]
            ind_nonextreme = which(one_sided_null_scores > observed.score)
            ind_extreme = which(one_sided_null_scores <= observed.score)
          } else if (observed.score > median_null_scores){
            one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores > median_null_scores)]
            ind_nonextreme = which(one_sided_null_scores < observed.score)
            ind_extreme = which(one_sided_null_scores >= observed.score)
          }

          if (length(ind_extreme) > maxnum_extreme || i == length(permulated_foregrounds)){
            permPval = min(maxnum_extreme+1, length(ind_extreme)+1)/(length(one_sided_null_scores)+1)   ###min(length(computed_permulated_scores)+1, length(permulated_foregrounds)+1)
            corr_score = sign(observed.score-median_null_scores)*(-log10(permPval))
            break
          }
        }
      }
    }
  } else {
    permulated_scores = rep(NA, length(permulated_foregrounds))
    for (i in 1:length(permulated_foregrounds)){
      fg_exist = checkForegrounds(maf, permulated_foregrounds[[i]])
      if (length(fg_exist) >= min.fg){
        permulated_score_i = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=fg_exist)
        permulated_scores[i] = permulated_score_i$score
      }
    }
    computed_permulated_scores = permulated_scores[!is.na(permulated_scores)]
    median_null_scores = median(computed_permulated_scores)
    if (observed.score <= median_null_scores){
      one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores < median_null_scores)]
      ind_extreme = which(one_sided_null_scores <= observed.score)
    } else if (observed.score > median_null_scores){
      one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores > median_null_scores)]
      ind_extreme = which(one_sided_null_scores >= observed.score)
    }

    permPval = (length(ind_extreme)+1)/(length(one_sided_null_scores)+1)
    corr_score = sign(observed.score - median_null_scores)*(-log10(permPval))
  }
  out = data.frame("permPval"=permPval, "corr_score"=corr_score, "uncorr_score"=observed.score)
  out
}

#' @keywords internal
run_phyloConverge_continuousTraitPermulations=function(foregrounds, num_foreground_tips, permulated_foregrounds, neutralMod, maf, refseq, feature=NULL, alpha=0.05, min.fg=2, method="LRT", mode="CONACC", adapt=T){
  print("Running phyloConverge with continuous trait permulations as input")
  #PHYLOP AUTOMATICALLY PRUNES TREE TO ONLY INCLUDE SPECIES IN ALIGNMENT - GIVES WARNING MESSAGE
  observed.score = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=foregrounds)
  observed.score = observed.score$score

  #Get neutral tree from neutral tree model
  neutral_tree<-read.tree(text=myMod$tree)
  print(neutral_tree)

  #Get optimal rate model - do this here instead of in the loop because it is based on the real data and we only need to get it once
  #WAIT should it be based on the real data or based on the permulated values???
  orm = getOptimalRateModel(foregrounds, neutral_tree, pthreshold = 0.25, lthreshold = 1.3)
  #Makes neutral tree into a list of trees of length 1; necessary for some functions to read it properly
  masterTree = list()
  masterTree[[1]] = neutral_tree
  names(masterTree) = c("masterTree")
  #MIGHT NEED TO DO THIS INSTEAD - char2PathsCategorical requires a trees object with tree$ap$matIndex, not just a list of trees
  #This function is slow, so run as few times as possble or see if there's a way around this; Nathan mentioned Maria wrote a faster version?
  #treeobj<-readTrees("mean_length_neutral_tree.DeanSpeciesOnly.tre")
  if (adapt){
    max_permulations = length(permulated_foregrounds)
    maxnum_extreme = round(alpha*max_permulations) ### centering on median --> the same pruning threshold on both sides
    permulated_scores = rep(NA, length(permulated_foregrounds))
    for (i in 1:length(permulated_foregrounds)){
      #Subset permulated continuous data to only include species in alignment
      subset_perm = permulated_foregrounds[[i]][which(names(permulated_foregrounds[[i]]) %in% names(maf))]
      print("Subset of permulated continuous trait values:")
      print(length(subset_perm))
      print(subset_perm)
      #Get top n permulated foregrounds, where n is the number of real foreground tips present in this aln
      sort_perm = (-(sort(subset_perm)))
      print("Sorted permulated continuous traits:")
      print(sort_perm)
      perm_fg_species = names(sort_perm)[1:num_foreground_tips]
      print("Permulated foreground tips:")
      print(length(perm_fg_species))
      print(perm_fg_species)
      #Encode all species as either foreground or background based on permulations
      #Foreground = TRUE; this will tell char2TreeCategorical to return a binary phenotype tree
      #perm_all_species = unlist(sapply(neutral_tree$tip.label, function(x) if(x %in% perm_fg_species){"TRUE"}else{"FALSE"}))
      #Get internal nodes from sister permulated foreground species
      #NEED NEW FUNCTION FROM PFENNING LAB
      #pdf("perm_fg_tree_char2TreeCategorical.pdf")
      #perm_fg_tree = char2TreeCategorical(perm_all_species, masterTree, model=orm, useSpecies=names(maf), plot=TRUE)
      #dev.off()
      #print(perm_fg_tree)
      #I THINK this gives us a vector of every node in the tree and whether it should be 0, 1, or NA; just need to get this back to species names and we should be good; need to figure out how to get this into phyloP format though
      #perm_fg_paths = char2PathsCategorical(perm_all_species, treeobj, model=orm, useSpecies=names(maf))
      #print(perm_fg_paths)
#      rate_models = list(getMatrixFromAbbr("ER",2), getMatrixFromAbbr("ARD",2))
#      names(rate_models) = c("ER", "ARD")
#      #print(rate_models)
#      pdf("node_states.longeraln.pdf", height=25, width=17)
#      node_states = visCompareTwoRateModels(rate_models$ER, rate_models$ARD, masterTree, perm_all_species, mode = "match")
#      dev.off()
#      print(node_states$states)
#      if(orm=="ER"){
#        print(node_states$states[,"statesA"])
#      } else{ #ARD
#        print(node_states$states[,"statesB"])
#      }
      #pdf("fg2tree.all.pdf", height=25, width=17, onefile=TRUE)
      fg2t_all = foreground2Tree(perm_fg_species, masterTree, plotTree=F, clade="all", useSpecies=names(maf))
      #fg2t_ancestral = foreground2Tree(perm_fg_species, masterTree, plotTree=T, clade="ancestral", useSpecies=names(maf))
      #fg2t_terminal = foreground2Tree(perm_fg_species, masterTree, plotTree=T, clade="terminal", useSpecies=names(maf))
      #dev.off()
      names(fg2t_all$edge.length)=nameEdges_all(fg2t_all)
      #print(fg2t_all)
      print(fg2t_all$edge.length)
      #Permulated foregrounds are a combination of foreground species and foreground internal branches
      fg_exist = names(fg2t_all$edge.length)[which(fg2t_all$edge.length==1)]
      print(fg_exist)
      #The rest of the function should work as before
      if (length(fg_exist) >= min.fg){
        permulated_score_i = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=fg_exist)
        permulated_scores[i] = permulated_score_i$score
        computed_permulated_scores = permulated_scores[!is.na(permulated_scores)]
        if (length(computed_permulated_scores) >= 2*maxnum_extreme){
          median_null_scores = median(computed_permulated_scores)
          if (observed.score <= median_null_scores){
            one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores < median_null_scores)]
            ind_nonextreme = which(one_sided_null_scores > observed.score)
            ind_extreme = which(one_sided_null_scores <= observed.score)
          } else if (observed.score > median_null_scores){
            one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores > median_null_scores)]
            ind_nonextreme = which(one_sided_null_scores < observed.score)
            ind_extreme = which(one_sided_null_scores >= observed.score)
          }

          if (length(ind_extreme) > maxnum_extreme || i == length(permulated_foregrounds)){
            permPval = min(maxnum_extreme+1, length(ind_extreme)+1)/(length(one_sided_null_scores)+1)   ###min(length(computed_permulated_scores)+1, length(permulated_foregrounds)+1)
            corr_score = sign(observed.score-median_null_scores)*(-log10(permPval))
            break
          }
        }
      }
    }
  } else {
    permulated_scores = rep(NA, length(permulated_foregrounds))
    for (i in 1:length(permulated_foregrounds)){
      #Subset permulated foregrounds to only include species in alignment
      subset_perm_fg = permulated_foregrounds[[i]][which(names(permulated_foregrounds[[i]]) %in% names(maf))]
      print(subset_perm_fg)
      #Get top n permulated foregrounds, where n is the number of real foreground tips present in this aln
      sort_perm_fg = (-(sort(subset_perm_fg)))
      print(sort_perm_fg)
      perm_fg_species = names(sort_perm_fg)[1:num_foreground_tips]
      print(perm_fg_species)
      #Get internal nodes from sister permulated foreground species
      fg2t_all = foreground2Tree(perm_fg_species, masterTree, plotTree=F, clade="all", useSpecies=names(maf))
      names(fg2t_all$edge.length)=nameEdges_all(fg2t_all)
      #Permulated foregrounds are a combination of foreground species and foreground internal branches
      fg_exist = names(fg2t_all$edge.length)[which(fg2t_all$edge.length==1)]
      #The rest of the function should work as before
      if (length(fg_exist) >= min.fg){
        permulated_score_i = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=fg_exist)
        permulated_scores[i] = permulated_score_i$score
      }
    }
    computed_permulated_scores = permulated_scores[!is.na(permulated_scores)]
    median_null_scores = median(computed_permulated_scores)
    if (observed.score <= median_null_scores){
      one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores < median_null_scores)]
      ind_extreme = which(one_sided_null_scores <= observed.score)
    } else if (observed.score > median_null_scores){
      one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores > median_null_scores)]
      ind_extreme = which(one_sided_null_scores >= observed.score)
    }

    permPval = (length(ind_extreme)+1)/(length(one_sided_null_scores)+1)
    corr_score = sign(observed.score - median_null_scores)*(-log10(permPval))
  }
  out = data.frame("permPval"=permPval, "corr_score"=corr_score, "uncorr_score"=observed.score)
  out
}




#'Scan a given sequence alignment to compute bias-corrected conservation/acceleration scores
#' @param maf an MSA object containing the sequence alignment
#' @param foregrounds a character vector containing the names of the foreground species
#' @param permulated_foregrounds a list object containing the sets of fake foreground species generated by permulation
#' @param neutralMod neutral nucleutide substitution model
#' @param refseq reference species
#' @param offset offset for the coordinates in the alignment. If NULL, the offset specified in the alignment is used
#' @param stride interval (in bp) of positions of sliding windows to be scored (default 1, meaning scoring every nucleotide)
#' @param window size (in bp) of the sliding windows to be scored (default 1)
#' @param alpha target significance level to control for
#' @param min.fg minimum number of foreground species required
#' @param method scoring method for phyloP (default "LRT")
#' @param mode scoring mode for phyloP (default "CONACC")
#' @param adapt Boolean flag for performing adaptive permulation (adapt = TRUE for adaptive permulation, adapt = FALSE for complete permulations, default TRUE)
#' @return out_df a data frame containing the start and end coordinates of the sliding windows and their corresponding phyloConverge scores
#' @export
scanWithPhyloConverge=function(maf, foregrounds, permulated_foregrounds, neutralMod, refseq, offset=NULL, stride=1, window=1, alpha=0.05, min.fg=2, method="LRT", mode="CONACC", adapt=T){
  if (is.null(offset)){
    offset=maf$offset
    coord_range = coord.range.msa(maf) - offset
  } else {
    offset=offset
    coord_range = coord.range.msa(maf)
  }

  flank = (window-1)/2
  start_pos = (window-1)/2 + 1
  scored_pos = seq(start_pos, coord_range[2], stride)

  bed_table = data.frame("chr"=rep("chr1", length(scored_pos)), "start"=scored_pos-flank, "end"=scored_pos+flank, "pos"=as.character(scored_pos))
  featureout = convertBedToFeature(bed_table, refseq)

  scan_score = rep(NA, nrow(featureout))
  for (i in 1:nrow(featureout)){
    print(i)
    score_i = phyloConverge(foregrounds, permulated_foregrounds, neutralMod, maf, refseq, featureout[i,], alpha=alpha, min.fg=min.fg, method=method, mode=mode, adapt=adapt)
    scan_score[i] = score_i$corr_score
  }
  position = offset + scored_pos

  out_df = data.frame("start"=position-flank, "end"=position+flank, "corr_score"=scan_score)
  out_df
}

#'Count number of foreground tips present in alignment
#' @param maf an MSA object containing the sequence alignment
#' @param foregrounds a character vector containing the names of the foreground species
#' @export
countFgTips=function(maf, foregounds){
   tips<-names(maf)
   fg_count<-length(intersect(tips, foregrounds))
   fg_count
}

#' Get names for both tips and internal branches of a phylo object
#' @param tree a phylo object
#' @return a vector tip labels and node names, sorted to match tree$edge
#' @export
nameEdges_all=function(tree){
  all_labels = c(tree$tip.label, tree$node.label)
  labels_ordered = c()
  for(i in 1:nrow(tree$edge)){
    idx=tree$edge[i,2]
    labels_ordered = c(labels_ordered, all_labels[idx])
  }
  labels_ordered
}

